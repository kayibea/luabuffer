local buffer = require("buffer")

describe("Buffer read/write methods", function()
  it("writes and reads UInt32LE at offset 1", function()
    local buf = buffer.alloc(4)
    buf:writeUInt32LE(0x78563412, 1)
    assert.are.equal(buf:readUInt32LE(1), 0x78563412)
  end)

  it("writes and reads UInt32LE with omitted offset (defaults to 1)", function()
    local buf = buffer.alloc(4)
    buf:writeUInt32LE(0x78563412)
    assert.are.equal(buf:readUInt32LE(), 0x78563412)
  end)

  it("writes and reads UInt32BE at offset 1", function()
    local buf = buffer.alloc(4)
    buf:writeUInt32BE(0x12345678, 1)
    assert.are.equal(buf:readUInt32BE(1), 0x12345678)
  end)

  it("writes and reads UInt32BE with omitted offset (defaults to 1)", function()
    local buf = buffer.alloc(4)
    buf:writeUInt32BE(0x12345678)
    assert.are.equal(buf:readUInt32BE(), 0x12345678)
  end)

  it("writes and reads FloatLE at offset 1", function()
    local buf = buffer.alloc(4)
    buf:writeFloatLE(3.14, 1)
    assert.is_true(math.abs(buf:readFloatLE(1) - 3.14) < 1e-6)
  end)

  it("writes and reads FloatLE with omitted offset (defaults to 1)", function()
    local buf = buffer.alloc(4)
    buf:writeFloatLE(3.14)
    assert.is_true(math.abs(buf:readFloatLE() - 3.14) < 1e-6)
  end)

  it("writes and reads FloatBE at offset 1", function()
    local buf = buffer.alloc(4)
    buf:writeFloatBE(2.71, 1)
    assert.is_true(math.abs(buf:readFloatBE(1) - 2.71) < 1e-6)
  end)

  it("writes and reads FloatBE with omitted offset (defaults to 1)", function()
    local buf = buffer.alloc(4)
    buf:writeFloatBE(2.71)
    assert.is_true(math.abs(buf:readFloatBE() - 2.71) < 1e-6)
  end)

  it("writes and reads DoubleLE at offset 1", function()
    local buf = buffer.alloc(8)
    buf:writeDoubleLE(1.23456789, 1)
    assert.is_true(math.abs(buf:readDoubleLE(1) - 1.23456789) < 1e-12)
  end)

  it("writes and reads DoubleLE with omitted offset (defaults to 1)", function()
    local buf = buffer.alloc(8)
    buf:writeDoubleLE(1.23456789)
    assert.is_true(math.abs(buf:readDoubleLE() - 1.23456789) < 1e-12)
  end)

  it("writes and reads DoubleBE at offset 1", function()
    local buf = buffer.alloc(8)
    buf:writeDoubleBE(9.87654321, 1)
    assert.is_true(math.abs(buf:readDoubleBE(1) - 9.87654321) < 1e-12)
  end)

  it("writes and reads DoubleBE with omitted offset (defaults to 1)", function()
    local buf = buffer.alloc(8)
    buf:writeDoubleBE(9.87654321)
    assert.is_true(math.abs(buf:readDoubleBE() - 9.87654321) < 1e-12)
  end)

  it("tostring returns utf8 string", function()
    local buf = buffer.from("hello")
    assert.are.equal(buf:tostring(), "hello")
  end)

  it("tostring returns hex string", function()
    local buf = buffer.from("hi")
    assert.are.equal(buf:tostring("hex"), "6869")
  end)

  it("tostring supports start/end slicing", function()
    local buf = buffer.from("abcdef")
    assert.are.equal(buf:tostring("utf8", 2, 4), "bcd")
    assert.are.equal(buf:tostring("utf8", -3, -1), "def")
    assert.are.equal(buf:tostring("utf8", 10, 20), "")
  end)

  it("throws on out-of-bounds read/write", function()
    local buf = buffer.alloc(4)
    assert.has_error(function() buf:writeUInt32LE(1, 2) end)
    assert.has_error(function() buf:readUInt32LE(2) end)
    assert.has_error(function() buf:writeFloatBE(1.0, 2) end)
    assert.has_error(function() buf:readDoubleLE(2) end)
  end)

  it("throws on unsupported encoding for tostring", function()
    local buf = buffer.from("abc")
    assert.has_error(function() buf:tostring("base64") end)
  end)

  it("writes and reads UInt16LE at offset 1", function()
    local buf = buffer.alloc(2)
    buf:writeUInt16LE(0x1234, 1)
    assert.are.equal(buf:readUInt16LE(1), 0x1234)
  end)

  it("writes and reads UInt16LE with omitted offset (defaults to 1)", function()
    local buf = buffer.alloc(2)
    buf:writeUInt16LE(0xBEEF)
    assert.are.equal(buf:readUInt16LE(), 0xBEEF)
  end)

  it("writes and reads Int16LE at offset 1", function()
    local buf = buffer.alloc(2)
    buf:writeInt16LE(-12345, 1)
    assert.are.equal(buf:readInt16LE(1), -12345)
  end)

  it("writes and reads Int16LE with omitted offset (defaults to 1)", function()
    local buf = buffer.alloc(2)
    buf:writeInt16LE(-32768)
    assert.are.equal(buf:readInt16LE(), -32768)
  end)

  it("throws on out-of-bounds read/write for UInt16LE/Int16LE", function()
    local buf = buffer.alloc(2)
    assert.has_error(function() buf:writeUInt16LE(1, 2) end)
    assert.has_error(function() buf:readUInt16LE(2) end)
    assert.has_error(function() buf:writeInt16LE(1, 2) end)
    assert.has_error(function() buf:readInt16LE(2) end)
  end)

  describe("write(string[, offset[, length]][, encoding])", function()
    it("writes a string at offset 1 by default", function()
      local buf = buffer.alloc(8)
      local written = buf:write("hi")
      assert.are.equal(written, 2)
      assert.are.equal(buf[1], string.byte("h"))
      assert.are.equal(buf[2], string.byte("i"))
    end)

    it("writes a string at a given offset", function()
      local buf = buffer.alloc(8)
      local written = buf:write("hi", 3)
      assert.are.equal(written, 2)
      assert.are.equal(buf[3], string.byte("h"))
      assert.are.equal(buf[4], string.byte("i"))
    end)

    it("writes only up to the specified length", function()
      local buf = buffer.alloc(8)
      local written = buf:write("abcdef", 1, 3)
      assert.are.equal(written, 3)
      assert.are.equal(buf[1], string.byte("a"))
      assert.are.equal(buf[2], string.byte("b"))
      assert.are.equal(buf[3], string.byte("c"))
      assert.are.equal(buf[4], 0)
    end)

    it("truncates write if string is longer than remaining buffer", function()
      local buf = buffer.alloc(4)
      local written = buf:write("hello world")
      assert.are.equal(written, 4)
      assert.are.same({ buf[1], buf[2], buf[3], buf[4] },
        { string.byte("h"), string.byte("e"), string.byte("l"), string.byte("l") })
    end)

    it("writes hex string with encoding argument", function()
      local buf = buffer.alloc(4)
      local written = buf:write("6869", 1, nil, "hex")
      assert.are.equal(written, 2)
      assert.are.equal(buf[1], string.byte("h"))
      assert.are.equal(buf[2], string.byte("i"))
    end)

    it("writes nothing and returns 0 if length is 0", function()
      local buf = buffer.alloc(4)
      local written = buf:write("abc", 1, 0)
      assert.are.equal(written, 0)
    end)

    it("throws on negative offset", function()
      local buf = buffer.alloc(8)
      assert.has_error(function() buf:write("hi", 0) end)
      assert.has_error(function() buf:write("hi", -1) end)
    end)

    it("throws if offset is larger than buffer size", function()
      local buf = buffer.alloc(4)
      assert.has_error(function() buf:write("abc", 5) end)
    end)

    it("throws if length is negative or exceeds buffer size", function()
      local buf = buffer.alloc(4)
      assert.has_error(function() buf:write("abc", 1, -1) end)
      assert.has_error(function() buf:write("abc", 1, 5) end)
    end)

    it("writes one byte if offset is exactly buffer size (last byte)", function()
      local buf = buffer.alloc(4)
      local written = buf:write("abc", 4)
      assert.are.equal(written, 1)
      assert.are.equal(buf[4], string.byte("a"))
    end)

    it("throws on unsupported encoding", function()
      local buf = buffer.alloc(8)
      assert.has_error(function() buf:write("abc", 1, nil, "base64") end)
    end)
  end)
end)
